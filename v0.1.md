# Version 0.1

## 0) orient yourself (2–3 days)

* **learn the moving parts:** identity provider (IdP), service provider (SP), authorization server, resource server, Relying Party.
* **standards to skim (save links/bookmarks):**

  * OAuth 2.0 (RFC 6749), OAuth 2.1 draft mental model
  * OpenID Connect Core 1.0 (OIDC)
  * JWT (RFC 7519), JWS/JWK (RFC 7515/7517), PKCE (RFC 7636)
  * Sessions vs tokens; refresh tokens, rotation, revocation
* **choose your protocols:** prefer **OIDC** over SAML for greenfield web+API SSO. Keep SAML only if you must interop with legacy enterprise SPs.

## 1) define scope & success (1 day)

* **users:** human users only? service accounts too?
* **auth methods:** email+password, social login (Google/Microsoft), enterprise SAML? MFA? WebAuthn?
* **clients:** web SPA, server-rendered app, native mobile, CLI.
* **flows to support:** OIDC Authorization Code + PKCE (mandatory), Device Code (optional), Client Credentials (service-to-service).
* **non-goals:** what you explicitly won’t do in v1 (e.g., account recovery via phone).
* **acceptance criteria:** login in < 2s, 99.9% auth uptime, audit log for all privileged events, etc.

## 2) architecture decisions (1–2 days)

* **build vs adopt:**

  * *Adopt*: run **Dex** or **Ory Hydra + Kratos** as managed auth core; your Go services integrate via OIDC. Faster, fewer foot-guns.
  * *Build-light*: compose with Go libs (**go-oidc**, **golang.org/x/oauth2**, **lestrrat-go/jwx**, **go-webauthn/webauthn**, **gofrs/uuid**). You still implement consent, sessions, clients, keys, policies.
* **storage:** Postgres for users, sessions, consents, clients, audit; Redis for ephemeral state (PKCE, nonce, rate-limits), and blacklists if you insist on revocation lists.
* **keys:** asymmetric signing (RS256/ES256). Store private keys in KMS (Cloud KMS, Vault). Publish JWKS at `/.well-known/jwks.json`.
* **domains:** dedicated auth domain (e.g., `auth.example.com`).
* **apps trust:** all apps validate tokens against your JWKS, cache keys, and enforce audience/issuer checks.

## 3) data & security model (2–3 days)

* **user model:** id, primary email (unique), verified flag, password hash (Argon2id), MFA factors, recovery options, profile claims.
* **client model (OIDC):** client_id, redirect_uris, response_types, grant_types, scopes, token lifetimes, consent policy.
* **token strategy:**

  * Access token: short TTL (5–10 min), audience-scoped, opaque or JWT.
  * Refresh token: rotation + binding (pairwise), TTL 30–90 days, one-time use.
  * ID token: JWT, minimal PII, never use for API auth.
* **MFA:** TOTP in v1; WebAuthn as stretch. Step-up MFA for sensitive scopes.
* **password policy:** Argon2id parameters tuned for your infra; breach checks (k-anon haveibeenpwned style).
* **privacy & compliance:** data retention, consent, GDPR basics (DPO email, export/delete flows).

## 4) minimal product plan (1–2 weeks)

deliverable: an internal IdP with OIDC Code + PKCE and a basic consent UI.

* **endpoints:**

  * `/.well-known/openid-configuration` (discovery)
  * `/authorize`, `/token`, `/userinfo`, `/introspect` (if using opaque tokens), `/revocation`, `/jwks.json`
* **login UI:** username/password + email verification, basic “consent for scopes” screen.
* **session mgmt:** secure cookies (SameSite=Lax/Strict, HttpOnly, Secure), CSRF tokens, short session + rolling refresh.
* **admin UI:** register clients, rotate keys, view metrics.
* **email:** transactional service for verification and reset; domain-signed (DKIM/SPF/DMARC).
* **observability:** structured logs with correlation IDs; metrics (auth latency, error rates, token issuance); audit log tables.

## 5) integration patterns (3–4 days)

* **service-to-service:** Client Credentials; issue audience-scoped JWTs for APIs.
* **web apps:** Auth Code + PKCE; store only session or short-lived access token in memory; never localStorage for long-lived secrets.
* **SPAs/mobile:** use backend-for-frontend (BFF) where possible to avoid exposing refresh tokens to browsers.
* **legacy apps:** SAML bridge via Dex or a gateway if mandated.

## 6) deploy & platform (3–5 days)

* **containerization:** Dockerfiles for auth service + UI; multi-stage builds; non-root user; distroless image if possible.
* **compose/k8s:** docker-compose for local; Helm/Kustomize for staging/prod.
* **Postgres:** managed instance preferred; strict network ACL; separate roles for read/write; daily snapshots.
* **Redis:** for state, with AOF persistence; key TTLs for all temp artifacts.
* **TLS:** terminate at ingress; HSTS; mTLS for internal service-to-service if you can.
* **secrets:** mounted from Vault/KMS; no secrets in env for long-lived values.
* **rate limiting & WAF:** per IP and per username on auth endpoints; bot detection on `/authorize`.
* **backups & DR:** test restore; document RTO/RPO.

## 7) quality gates (parallel, ongoing)

* **threat modeling:** STRIDE on login, token, reset, consent; document mitigations.
* **automated tests:**

  * unit: token issuance/validation, PKCE/nonce, scope filtering
  * integration: full OIDC flow with a fake client
  * e2e: login + consent + callback; MFA; refresh rotation
* **security tests:** password spraying resistance, lockouts with exponential backoff, reset-link replay, CSRF, SSRF on redirect_uris, open redirect checks.
* **lint & policy:** go vet, staticcheck, golangci-lint; OIDC conformance checklist.
* **load tests:** target 95p < 150ms for `/authorize` and `/token`; verify DB/Redis contention.

## 8) feature hardening (1–2 weeks)

* **account lifecycle:** signup, verification, recovery, deactivation, deletion (GDPR export/delete).
* **MFA enrollment & recovery:** backup codes; policy to require MFA for admin roles.
* **scope design:** least-privilege, purpose-driven scopes (e.g., `profile:read`, `invoices:write`).
* **consent UX:** show client, scopes, data use summary, last used; remember consent per client+scope.
* **session dashboard:** users can see devices/sessions and revoke.
* **admin:** client CRUD, rotate signing keys (kid versioning), revoke tokens by jti or sub.

## 9) rollout plan (3–5 days)

* **pilot:** integrate 1 internal app as RP; run in staging; collect metrics & feedback.
* **migration:** for existing apps, add OIDC in parallel with legacy auth, then flip.
* **incident playbooks:** lockout storms, key compromise, email outages, DB failover.
* **SLOs & alerts:** auth error rate, token failures, SMTP queue, DB/Redis saturation.

## 10) docs you should ship

* **developer guide:** “How to register a client and sign in users.”
* **security guide:** token lifetimes, storage rules, do’s/don’ts.
* **runbook:** deploy, rotate keys, emergency revoke, restore from backup.
* **privacy policy:** what claims you issue and why.

---

## go-specific ingredients to evaluate (no code)

* **OIDC/OAuth:** `go-oidc` (RP validation), `golang.org/x/oauth2` (flows), **Fosite** (full OAuth2/OIDC framework) if you want to build an AS yourself.
* **JWT/JWK:** `lestrrat-go/jwx` or `go-jose` for signing/verification, JWKS rotation.
* **MFA/WebAuthn:** `duo-labs/webauthn` or `go-webauthn/webauthn`.
* **Passwords:** `golang.org/x/crypto/argon2` via a helper lib; password zxcvbn estimator for UX.
* **HTTP & middleware:** `net/http` + `chi` or `gin`; `secure` middleware for headers; CSRF middleware for forms.
* **email:** any SMTP client + provider (SendGrid, Postmark).
* **observability:** `zap` or `zerolog`; Prometheus metrics; OpenTelemetry tracing.

---

## milestones & checklists (condensed)

**M0 – foundations (week 1):** decisions made, diagrams drawn, PoC repo, Postgres + Redis + Docker up.
**M1 – protocol skeleton (week 2):** `/authorize`, `/token`, `/jwks.json`, discovery doc, one sample client round-trips.
**M2 – real users (week 3):** login UI, email verification, sessions, consent, audit logs.
**M3 – security hardening (week 4):** MFA (TOTP), refresh rotation, key rotation policy, rate limits.
**M4 – integrations (week 5):** at least two apps live via OIDC; BFF pattern validated.
**M5 – production readiness (week 6):** SLOs, alerts, runbooks, backups tested, incident drills.

---

## common foot-guns to avoid

* Using ID tokens as API bearer tokens. Don’t.
* Long-lived access tokens in browsers or localStorage. Use short tokens + BFF.
* Skipping PKCE for public clients.
* Not checking `aud`, `iss`, `exp`, `iat`, `nonce`, `azp` during token validation.
* Weak redirect URI rules (wildcards, http). Require exact HTTPS matches.
* Forgetting clock skew when validating `exp`/`nbf`.
